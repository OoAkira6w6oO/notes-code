# 基本介绍

## 应用场景

- Linux运维——服务器管理
- JavaEE、python——shell脚本进行**程序or服务器的维护，定时备份**等
- 大数据——使用shell程序来管理集群
- Shell根本功能
  - 向Linux内核发送请求
  - 用户可以用Shell来启动、挂起、停止甚至是编写一些程序


## 运行原理

- 命令行解释器
- 通过shell驱动内核kernel，kernel驱动硬件

- shell输出一个提示符，等待输入一个命令行，然后执行这个命令
- 如果命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，他将加载并运行这个文件。运行完毕文件之后，shell再次输出一个提示符，等待下一个输入的命令行。

# 执行和操作

## 前提

- 必须确保有执行权限
  如果不给用户执行权限，也可以直接sh + 路径进行执行，意思是用sh执行（不推荐//Unix 系统上最传统的 Shell

  ```shell
  sh ./myShell.sh
  sh /root/shell/myShell.sh
  ```

## 标准执行过程

- 权限管理 & 执行

```shell
source [fileName] #让修改后的配置信息立即生效
chmod 744 myShell.sh
/root/shell/myShell.sh #绝对路径执行
./myShell.sh #相对路径执行
```

## 以后台方式运行

```shell
./myShell.sh &
```

也就是说 **Shell 会立即返回命令提示符**，你可以继续执行其他命令，而脚本会在后台运行。

长时间任务 / 并行任务 的时候使用

## 退出

ctrl + C

# 语法

## 文件名

- shell的脚本后缀一般是.sh，其实什么都可以

## 文件类型声明

- 开头的 **#!/bin/bash** 

  #! 是固定开头，后面的目录表明用哪一个shell进行解析

- 每行代码结尾不需要有分号

## 变量

### 变量的分类 & 转换

#### 系统变量

- $HOME / $PWD / $SHELL / $USER

  - `$` 来表示 **变量展开（variable expansion）**

  - **区分字面值和变量**：`$PATH` vs `PATH`

  - **方便解析**：Shell 遇到 `$` 就知道后面是变量名

  - **支持复杂表达式**：`${VAR}`、`$((expression))` 等

- 一般保存在/etc/profile

- 查询环境变量的值

  ```shell
  echo $变量名
  echo $PATH
  ```

#### 用户自定义变量

- 特点

  - **export 创建的环境变量**默认只在 **当前 Shell 会话及它启动的子进程** 中有效
  - **关闭终端窗口** 或 **退出 Shell 会话**，这些变量就会 **消失**，它们只存在于内存中

- 使用

  ```shell
  export MYVAR="Hello"
  echo $MYVAR   # 输出 Hello
  ```

#### 位置参数变量

- 特点

  - Shell 用来访问命令行参数的特殊变量
  - 命令行中`./myShell.sh 100 200`，想要在shell脚本内访问100和200的时候使用
  
- 使用

  | 变量    | 含义                                     |
  | ------- | ---------------------------------------- |
  | $0      | 当前脚本的名字 (`./myShell.sh`)          |
  | $1      | 第一个参数 (`100`)                       |
  | $3 … $9 | 第三个到第九个参数                       |
  | $#      | 参数个数 (`2`)                           |
  | $*      | 所有参数，作为一个整体 (`100 200`)       |
  | $@      | 所有参数，每个参数单独引用 (`100` `200`) |
  | $$      | 当前脚本进程的 PID                       |
  | $?      | 上一条命令的退出状态码                   |
  | $!      | 后台运行的最后一个进程的进程号PID        |

#### 预定义变量

- 特点
  - 也叫 **特殊变量** 或 **环境变量**
  - Shell 内置的、由系统或 Shell 自带的变量

- 使用

  ```shell
  #!/bin/bash
  
  echo "当前用户：$USER"
  echo "主目录：$HOME"
  echo "当前路径：$PWD"
  echo "Shell 程序：$SHELL"
  echo "随机数示例：$RANDOM"
  ```

### 查看变量

- 查看当前shell中所有变量，输入set即可，会给出
  - **用户自定义变量**
  - 环境变量
  - Shell 预定义变量（特殊变量）

### 变量名规则

- 字母、数字、下划线，不可数字开头
- 习惯大写

### 声明

```shell
# 声明变量 A
A=10
echo $A
# 撤销声明 A
unset A
# 声明只读变量
readonly B=99
echo $B
```

### 赋值

- 基本赋值

```shell
# 正确
A=10

# 错误（等号两侧有空格）
# A = 10   # 会报错
```

- 命令替换（获取命令输出赋值给变量）
  - **反引号 ``command``**
  - *$()**（推荐，支持嵌套，易读）

```shell
# 使用反引号
FILES=`ls -la`

# 使用 $()
FILES=$(ls -la)

# 输出变量内容
echo "$FILES"
```

## 注释

- 单行注释

  开头写#即可

- 多行注释

  <<!    ........ !

## 运算符

- 语法

  - $(())

  - $[]

  - expr
    - expr m + n
    - expr m - n
    - expr \\*
    - expr /
    - expr %

- 举例——计算(2+3)x4的值

  ```shell
  # $(( )) 算术扩展（推荐用法）
  RESULT1=$(((2+3)*4))
  echo $RESULT1
  
  A=2
  B=3
  RESULT=$(( (A+B)*4 ))
  echo $RESULT  # 20
  
  # $[ ] 算术扩展（旧式写法）
  RESULT2=$[(2+3)*4]
  echo $RESULT2
  
  # expr 命令方式（外部命令）,可读性不如 $(( )),效率低
  TEMP=`expr 2 + 3`
  RESULT3=`expr $TEMP \* 4`
  echo $RESULT3
  
  ```

- 举例——请求出命令行给出的两个整数参数之和

  ```shell
  # 脚本举例
  SUM=$(($1 + $2))
  SUM=$[$1 + $2] # 使用旧式算术扩展
  
  # 执行举例
  chmod +x sum.sh        # 赋予执行权限
  ./sum.sh 100 200
  ```

# 条件判断

## if判断

- [condition] / ((condition))

- 非空返回true

```shell
if (( NUM > 0 )); then # [ $NUM -gt 0 ];
    echo "正数"
elif (( NUM < 0 ))
then
    echo "负数"
else
    echo "零"
fi
```

* 条件判断式，中括号和条件判断式之间必须有空格，本质是解析成新的参数
* 分号 `;` 表示 **前一条命令结束，下一条命令开始**，如果换行写，也可以省略分号

## 比较两个整数

| 符号 | 含义                   |
| ---- | ---------------------- |
| =    | 字符串比较             |
| -z   | 判断字符串长度是否为零 |
| -lt  | <                      |
| -le  | <=                     |
| -eq  | =                      |
| -gt  | >                      |
| -ge  | >=                     |
| -ne  | !=                     |

## 判断文件权限

| 符号 | 含义         |
| ---- | ------------ |
| -r   | 有读的权限   |
| -w   | 有写的权限   |
| -x   | 有执行的权限 |

## 判断文件类型

| 符号 | 含义                       |
| ---- | -------------------------- |
| -f   | 文件存在并且是一个常规文件 |
| -e   | 文件存在                   |
| -d   | 文件存在并且是一个目录     |

## 应用实例

| Q                                     | A                                                     |
| ------------------------------------- | ----------------------------------------------------- |
| ok是否等于ok                          | if [ "ok" = "ok" ]; then echo "equal"; fi             |
| 23是否大于22                          | if [ 23 -gt 22 ]; then echo "大于"; fi                |
| /root/install.log目录中的文件是否存在 | if [ -e /root/install.log ]; then echo "文件存在"; fi |

# 流程控制

## 流程控制case 

- 语法

```shell
case $变量名 in
  "值1")
    # 如果变量的值是值1，执行程序1
    ;;
  "值2")
    # 如果变量的值是值2，执行程序2
    ;;
  *)
    # 如果变量的值不是以上值，执行此程序
    ;;
esac

```

- 举例

```shell
#!/bin/bash

COLOR=$1   # 从命令行获取变量

case $COLOR in
  "red")
    echo "你选择了红色"
    ;;
  "blue")
    echo "你选择了蓝色"
    ;;
  "green")
    echo "你选择了绿色"
    ;;
  *)
    echo "选择的颜色不在列表中"
    ;;
esac
```



## 流程控制for

- 语法

```shell
# 遍历列表循环
for 变量 in 值1 值2 值3 ...
do
  命令
done

# 算术循环（C 风格）
for ((初始值; 循环控制条件; 变量变化))
do
  命令
done
```

- 举例

```shell
#!/bin/bash

for COLOR in red blue green
do
  echo "颜色是 $COLOR"
done
```

```shell
#!/bin/bash

for ((i=1; i<=5; i++))
do
  echo "第 $i 次循环"
done
```

## 流程控制while

- 语法

```shell
while [ 条件 ]
do
  命令
done
```

- 举例

```shell
#!/bin/bash

i=1
while [ $i -le 5 ]
do
  echo "第 $i 次循环"
  i=$((i+1))
done
```

## 读取控制台输入 read

- 语法

```shell
read [选项] 变量名
# 作用：从终端读取输入，并把值存入指定变量
```

- 常用选项

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | -p   | 指定读取值时的提示符                                         |
  | -t   | 指定读取值时等待时间second，如果没有在指定的时间内输入，就不再等待了 |

- 举例

```shell
#!/bin/bash

# 提示用户输入 num1，等待时间 10 秒
read -t 10 -p "请输入一个数 num1= " NUM1

# 判断是否输入
if [ -z "$NUM1" ]; then
    echo "超时未输入，num1为空"
else
    echo "输入的是 num1=$NUM1"
fi
```

# 函数

## 系统函数

- Shell 中处理文件路径常用命令

### 系统函数basename

- 获取路径中的 **文件名部分**

```shell
basename [pathname] [suffix] # 获取路径中的 文件名部分,可选择去掉文件后缀
basename /home/aaa/test.txt .txt # 输出：test
```

### 系统函数dirname

- 获取路径中的 **目录部分**

```shell
dirname [pathname]
dirname /home/aaa/test.txt # 输出：/home/aaa
```

## 自定义函数

- 语法

  - `local` → 声明局部变量，防止污染全局变量
  
  ```shell
  [function] funname() {
      # 函数体：执行操作
      Action
      [return int]  # 可选，返回整数状态码
  }
  ```
  

- 举例

```shell
#!/bin/bash

# 定义函数，带参数
sum() {
    local a=$1    # 第一个参数
    local b=$2    # 第二个参数
    local result=$((a + b))
    echo $result  # 返回结果，用命令替换捕获
}

# 调用函数并传入参数
RESULT=$(sum 5 10)
echo "两个数的和是：$RESULT"
```

# 实操

## 数据库备份

### 需求

1. 每天凌晨2:10备份数据库testDB到/data/backup/db

2. 备份开始和备份结束能够给出相应的提示信息

3. 备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式

   比如 2018-03-12_230201.tar.gz

4. 在备份的同时，检查是否有10天前备份的数据库文件，如果有，将其删除

### 分析

1. 确定在哪里写shell脚本
2. 利用脚本实现功能
3. 将脚本设置到crontab中

### 操作

1. 创建脚本位置
```shell
   cd /usr/sbin
vim mysql_db_backup.shell
   ```

2. 书写脚本

```shell
#!/bin/bash
#完成数据库的定时备份

#备份路径
BACKUP=/data/backup/db
#当前时间作为文件名
DATETIME=$(date+%Y_%m_%d_%H%M%S)

echo "开始备份"
echo "备份路径为$BACKUP/$DATETIME.tar.gz"

#数据库的登录信息
HOST=localhost
DB_USER=root
DB_PWD=root
DATABASE=testDB

#创建备份的路径
[ ! -d "$BACKUP/$DATETIME" ] && mkdir -p "$BACKUP/$DATETIME" # -p 是 mkdir 的选项，作用是 创建目录以及必要的父目录

#执行mysql的备份数据库指令
mysqldump -u${DB_USER} -p${DB_PWD} --host=$HOST $DATABASE | gzip > $BACKUP/$DATETIME/$DATETIME.sql.gz

#打包备份文件
cd $BACKUP
tar -zcvf $DATETIME.tar.gz $DATETIME
#删除临时目录
rm -rf $BACKUP/$DATETIME

#删除十天前的备份文件
find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -rf {}\;
# -mtime +10：修改时间超过 10 天 的文件
# -exec → 对找到的每个文件执行指定命令
# {}表示找到的文件
# \; → 表示 命令结束

echo "备份成功"
```

3. 设置定时执行

   ```shell
   crontab -e
   10 2 * * * /usr/sbin/mysql_db_backup.sh
   # 分钟 小时 日 月 星期
   ```
   
   
