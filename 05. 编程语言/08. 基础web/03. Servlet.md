# 目标解决的问题

- 静态资源和动态资源的区分

  - 静态资源

    - html

    - js

    - img

    - 音频视频


  - 动态资源

    - 代码动态生成的

    - Servlet

    - Thymeleaf

- Servlet就是要帮助解决【如何获得动态资源】，也就是需要程序处理的资源

# 定义

- 不是所有的Java类都可以处理客户端的请求，能处理Client请求并做出一套响应的技术标准，叫做Servlet
- Servlet是运行在服务端的，所以Servlet必须在WEB项目中开发，运行在Tomcat这样的服务器中（普通的Java项目是不能运行Servlet的）

# 执行过程

## STEP

1. Client通过Browser发送【请求】
2. Tomcat接收到请求后，将请求报文信息转换成HttpServletRequest对象，该对象中包含的请求中的所有信息
   Tomcat同时创建了一个HttpServletResponse对象，用于存储响应信息
3. 在代码中写了一些对应的类 implement Servlet规范
4. Tomcat根据request中的路径，找到对应的servlet，调用对应的方法，传入HttpServletRequest和HttpServletResponse

## 补充

- defaultServlet
  - 如果tomcat获取的是一个文件路径，tomcat会默认这是一个静态资源
  - 所有静态资源没匹配上，就去所有的Servlet中找
  - 没有匹配上任何Servlet，就会调用defaultServlet
  - 注意defaultServlet会在SpringMVC框架中有影响

# 最原始的开发流程

1. 创建javaWEB项目，同时将tomcat 添加为dependencies
2. 重写service方法

```java
public class UserServlet extends HttpServlet{
  @Override
  protected void service(HttpServletRequest request, HttpServletResponse reponse) throws ServletException, IOException{
    
    
  }
}
```



## 处理request

- request.get("username")
- 根据参数名获取参数值，无论参数在url后还是请求体内

## 写入response

```java
PrintWriter writer = response.getWriter();//该方法返回的是一个响应体中打印字符串的打印流
writer.write(info);
```

## 配置请求路径

- 在web/WEB-INF/web.xml中配置

```xml
<servlet>
  <servlet-name>userServlet</servlet-name>//请求的映射路径
  <servlet-class>全类名</servlet-class>//Servlet类
  <load-on-startup>6</load-on-startup>
</servlet>

<servlet-mapping>
  <servlet-name>userServlet</servlet-name>//和servlet标签中的name对应
  <url-pattern>/userServlet</url-pattern>//路径定义处，必须/开头
  <url-pattern>/userServlet2</url-pattern>
</servlet-mapping>
```

- 对应关系
  - 一个servlet-name可以对应多个url-pattern（需要时不同值）
  - 每个url-pattern只能对应一个servlet-name
  - 一个servlet可以对应多个servlet-mapping标签

- url-pattern的匹配模式
  - 精确匹配
  - 模糊匹配
    - 使用 * 作为通配符，*的部分进行模糊匹配
    - / ：匹配全部，不包括jsp文件
    - /*：匹配全部，包括jsp文件
    - /a/*
    - *.action

## 其他信息

### servlet-api.jar 的导入问题

- 继承自的Servlet正常属于servlet-api.jar，他其实内置于Tomcat中
- 关联Tomcat的时候，就会依赖到，在Tomcat的lib目录下自动携带
- scope：provided——意思就是编码的时候携带，运行的时候不会携带（服务器环境会提供，打包的时候不会携带）

### Content-Type响应头

- MIME——媒体类型，文件类型，响应的数据类型
  MIME类型用于告诉Client响应的数据是什么类型的数据
  默认当作HTML进行解析

- conf/web.xml文件中记录了每一个文件对应的MIME => 每一种文件后缀对应的MIME值
   => 在处理静态资源的时候都会这样自动映射
   => 动态资源就需要手动设置MIME

  ```java
  response.set("Content-Type", "text/html")
  ```

# 注解方式配置

```java
@WebServlet("/xxxxxxx")
@WebServlet(urlPatterns = {"/s1","/s2"})//大部分定义一个就够了
@WebServlet(value="/s1")//value和urlPatterns互为别名
@WebServlet(value="/s1", loadOnStartUp = 2)
```



- 如果没有正确的/，整个项目的URL配置有冲突的时候，会报`IllegalStateException: xxx`
- 注解中的loadOnStartup参数详见【生命周期】part

#  生命周期

## 涉及生命周期的方法的请求时机

- 第一次执行：构造器 -> init() -> service() 
- 每次执行：service
- 服务关闭：destroy

## 带来的问题

- 单例模式下，可能出现多用户访问造成的线程安全问题

- loadOnStartUp
  - -1: tomcat启动时不实例化该servlet（在第一次请求的时候才初始化
  - 其他正整数：tomcat在启动时，实例化该servlet的顺序，如果数据冲突了就自动处理启动顺序
  - 不建议直接写1: 共用的web.xml中用到了一些

# 源码解读

## Servlet 的继承结构

- HttpServlet, GenericServlet, Servlet, ServletConfig, Serialable
- 顶层interface中的方法（Servlet）
  - init 初始化
  - ServletConfig getServiceConfig() 获得设置信息
  - void service() 接收用户请求，返回响应信息
  - getServletInfo 字符串形式描述信息
  - destroy 资源回收
