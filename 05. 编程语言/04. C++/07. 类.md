# 访问控制

- public

  - set/get方法一般会是inline函数 <= 交给现代编译器处理即可

- private

  - 默认级别 = private

- protected

  - 自己 + 派生class可访问

- 语法

  ```C++
  public:
  //func
  //attribute
  ```

# 函数

## 普通函数

```C++
//内部定义
class Person{
  void disp(){
    
  }
}
//外部定义
void Person::disp(){
  
}
```

## 构造函数

- 必选项

- 构造函数的名字与类名相同
- 用于为数据成员设置初始值

```C++
class Person{
  Person(){}
}

// 隐式调用构造函数
Person p;
Person p(3);
// Person p();是错误的 <= 表示返回值是Person的函数

// 显式调用构造函数
Person p = Person(3);
```

- 缺省构造函数
  - 没有参数的构造函数
  - 即使不写也会自动生成一个

## 析构函数

- 可选项

- 释放对象后进行后处理
- 特点
  - 函数名是 ~[类名]
  - 没有返回值
  - 没有参数

```C++
class cMystring{
  char *text;
}
cMystring::~cMystring(){
  cout<<text<<"destructor\n";
  delete []text;
}
```

## 复制构造函数

- 必选项
  - 如果不手动定义，会自动生成

- 特点
  - 参数是同一个类的对象引用

```C++
class cData{
  int x;
  public:
  CData(const cData &another);
}

cData::cData(const cData &another){
  x = another.x;
}
```

## 变换构造函数

- 将对象转换为某种类型的操作符

- 只有一个参数的构造函数

```C++
class MyClass {
public:
    // 重载类型转换运算符
    operator unsigned int() const {//后面的 unsigned int 表示转换成的目标类型
        return value_;//没有返回类型，因为返回类型就是这个函数的返回值
    }

private:
    unsigned int value_ = 42;
};

int main() {
    MyClass cnt;

    unsigned int x = cnt;          // ✅ 隐式调用
    unsigned int y = cnt.operator unsigned int(); // ✅ 显式调用

    std::cout << x << " " << y << "\n"; // 输出 42 42
}

```

## 友元函数

- 函数说明前加入 friend 关键词，函数内部就可以直接调用private变量
- 友元函数不是成员函数，是一个独立的函数，在class内部外部定义均可

## operator函数

- 运算符重载函数

- 自定义对象在使用运算符（+、==、< 等）时的行为

```C++
class Vector2D {
private:
    double x_, y_;

public:
    Vector2D(double x, double y) : x_(x), y_(y) {}

    // ✅ 重载加号运算符
    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x_ + other.x_, y_ + other.y_);
    }

    // ✅ 重载输出运算符（友元函数）---两个操作数都显式传入，常用于需要对称的操作（如输出流、比较）
    friend std::ostream& operator<<(std::ostream& os, const Vector2D& v) {
        os << "(" << v.x_ << ", " << v.y_ << ")";
        return os;
    }
};

int main() {
    Vector2D a(3, 4);
    Vector2D b(1, 2);

    Vector2D c = a + b; // 调用 operator+()
    std::cout << c << std::endl; // 调用 operator<<()
}

```

# static

- 静态成员，可以直接访问

# this指针

- 指向当前对象的指针——存放当前对象的地址

# 友元类

- class A是class B的友元类，则A可以访问B中所有成员

```C++
class A{
  int va;
  public:
  
}

class B{
  int vb;
  public:
  friend class A;//A是B的友元类
}
```

# 内嵌类

- 类的嵌套定义
- 内嵌类并没有什么特权，只是在类的内部定义

# 实践

```C++
#include <iostream>
#include <string>
#include <utility>  // for std::move

class Person {
private:
    std::string name_;
    int age_ = 0;  // ✅ 默认成员初始化（C++11 新特性）

public:
    // 默认构造函数
    Person() = default;

    // 自定义构造函数
    Person(std::string name, int age)
        : name_(std::move(name)), age_(age) {}  // ✅ 使用 std::move 避免拷贝

    // 拷贝构造函数
    Person(const Person& other)
        : name_(other.name_), age_(other.age_) {
        std::cout << "Copy constructor called\n";
    }

    // 移动构造函数（C++11 新特性）
    Person(Person&& other) noexcept
        : name_(std::move(other.name_)), age_(other.age_) {
        std::cout << "Move constructor called\n";
    }

    // 拷贝赋值运算符
    Person& operator=(const Person& other) {
        if (this != &other) {
            name_ = other.name_;
            age_ = other.age_;
        }
        std::cout << "Copy assignment called\n";
        return *this;
    }

    // 移动赋值运算符（C++11 新特性）
    Person& operator=(Person&& other) noexcept {
        if (this != &other) {
            name_ = std::move(other.name_);
            age_ = other.age_;
        }
        std::cout << "Move assignment called\n";
        return *this;
    }

    // 析构函数
    ~Person() = default;

    // 常量成员函数
    void introduce() const {
        std::cout << "Hi, I'm " << name_ << " and I'm " << age_ << " years old.\n";
    }
};

// 派生类（演示 override）
class Student : public Person {
private:
    std::string school_;

public:
    using Person::Person;  // ✅ 继承基类构造函数（C++11 新特性）

    Student(std::string name, int age, std::string school)
        : Person(std::move(name), age), school_(std::move(school)) {}

    void introduce() const override {  // ✅ override 检查覆盖合法性
        std::cout << "Hi, I'm a student at " << school_ << ".\n";
    }
};

// 示例程序
int main() {
    Person p1("Alice", 30);
    p1.introduce();

    Person p2 = p1;              // 调用拷贝构造
    Person p3 = std::move(p1);   // 调用移动构造

    Student s("Bob", 20, "MIT");
    s.introduce();               // 调用子类的 override 方法

    return 0;
}

```

# const类

- const = 初始化后不能被改变
- 一旦是const类，想要访问内部的东西，只能访问const方法
  - 相当于声明这个函数是const对象也能使用的函数

```C++
class cConst{
  void disp() const;
}
void cConst::disp() const{
  
}
```

# C语言相关部分

## struct

- C++中，struct和class一样，只是缺省的控制权限不同
  - class —— private
  - strcut —— public

## union

- 缺省的访问控制为public

## 位段

- struct + 位指定

# .和->的区分

- `.`是拿着对象去找属性
- `->`是拿着地址去找属性
