# 继承

## 基本知识

- 语法

  ```C++
  class B: public A{
    
  }
  ```

- 基类 、父类

- 子类、派生类

  - 可以直接访问父类的public、protected，不能访问private
  - 访问的时候通过父类名称访问

- 控制访问（三种继承方式）

  - public
  - protected
  - private
  - 其实是如何访问public, protected成员的方式

- 构造函数的调用

  - 从父类开始，层层构造到子类

- 析构函数的调用

  - 从子类开始，逐层析构到父类

## 多重继承

- 每个基类名的前面都要加上public、protected或private说明，如果省略不写，则其缺省为private。 

```C++
class cMultiAB: public cMultiA, public cMultiB{
  
}
```

## 虚拟继承

- 为了解决菱形继承难题

- A <= B, C <= D
  - 非虚拟继承：调用D的基类的时候，会有两个A存在，编译错误
- 虚拟继承
  - B, C继承的时候 virtual public A

# 多态

## 静态结合

- static binding / early binding
- 编译阶段就确定函数调用指向哪个函数——调用的是父类的or子类的

## 动态结合

- dynamic binding / late binding
- 在运行时决定函数调用指向哪个函数
- 使用虚函数实现

## 虚函数

- Override
- 这个函数可以在子类中被重新定义；
- 即使通过基类指针调用，也要根据**实际对象类型**来决定调用哪个版本

```C++
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() { cout << "Animal speaks\n"; } // 虚函数
};

class Dog : public Animal {
public:
    void speak() override { cout << "Dog barks\n"; }
};

int main() {
    Animal a;
    Dog d;
    Animal* p = &d;

    a.speak(); // Animal speaks
    d.speak(); // Dog barks
    p->speak(); // ✅ Dog barks！（动态结合）
}

```

### 纯虚函数

- 纯虚函数
  - 没有函数体
  - virtual + '=0'

- 抽象类（abstract class）
  - **包含纯虚函数的类**
- 构造函数不能是虚函数
- 析构函数可以是虚函数

```C++
#include <iostream>
using namespace std;

// 抽象类：Animal
class Animal {
public:
    virtual void speak() = 0;  // ✅ 纯虚函数
};

// 具体子类：Dog
class Dog : public Animal {
public:
    void speak() override {    // 必须实现纯虚函数
        cout << "Dog barks\n";
    }
};

// 另一个子类：Cat
class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat meows\n";
    }
};

int main() {
    // Animal a; // ❌ 错误！抽象类不能实例化

    Dog d;
    Cat c;

    Animal* p1 = &d;
    Animal* p2 = &c;

    p1->speak();  // Dog barks
    p2->speak();  // Cat meows
}

```

