# 概述

- Java中一切都是对象，和前端交互时的标签组合、和后端交互时的DB中的表，都会对应JAVA中的一个对象。

- 类：对一类事物的描述，是抽象的，概念上的定义；

  对象：实际存在的该类事物的每一个个体，也称为实例 instance

- 设计类，其实就是设计类的成员

- 对象的特点

  - 可以有属性field、行为
  - 同一个类的两个instance，独立地拥有一套类的属性
  - 实例化
    - Person p1 = new Person();
  - 对象的失败复制
    - 如果写成Person p3 = p1; 就是将p1变量保存的对象地址值赋给p3，导致两者指向堆空间中的同一个对象实体。

- 调用属性 / 方法

  - 调用属性 ： 对象 . 属性名
  - 调用方法 ： 对象 .     方法名

- 一般在Java中调用方法，都是在class内定义了各种方法。

  在调用的时候，在main方法内部，定义一个本class的实体。

  然后再调用各个方法。

# 类的"封装性"

- 控制内部控制、对外暴露两部分

- 实现封装性的权限修饰符 —— Java中有四种

  |             | 类内部 | 同一个package | 不同包的子类 | 同一个工程 |
  | ----------- | ------ | ------------- | ------------ | ---------- |
  | private     | Yes    |               |              |            |
  | 缺省default | Yes    | Yes           |              |            |
  | protected   | Yes    | Yes           | Yes          |            |
  | public      | Yes    | Yes           | Yes          | Yes        |

- 权限修饰符可以修饰什么

  - 类的内部结构
  - 属性
  - 方法
  - 构造器
  - 内部类
  - 类：修饰类的话，只能用default和public

# 类的"继承性"

## 好处

- 提高代码复用性
- 为“多态性”的使用，提供了前提

## 语法

- class A extends B {}
- sub class 子类
- super class 父类

## 特点

- 一旦继承，subclass会继承superclass声明的结构、属性、方法
- superclass中的private属性，subclass也会继承。但无法直接访问，需要接触set/get方法

## 规定

- 一个superclass可以有多个subclass
- 一个娃只能有一个爸
- 可以多层继承

## 重写

- 子类可以重写父类的方法

- 重写后的方法，优先级更高

- 重写时，权限修饰符的规定

  => 想要覆盖掉别人，那必须权限更大

  => 子类不能重写父类中声明为private权限的方法

- 重写时，返回值的规定

  => void 只能是 void

  => 重写可以更小【父类返回值Object 子类可以返回String】

  => 基本数据类型 必须 相同

- 重写时，异常的规定

  => 父Exception 子RuntimeException

- 实际开发中的重写

  - 一般就直接copy父类函数声明就行
  - 直接写函数名，然后使用alt+/自动补全快捷键，就会提示出来重写的方法声明

- static方法不可被重写

  - 静态方法不能够被覆盖，是随着类的加载被加载的

# 构造器 constructor

- 一个类中，至少会有一个构造器

- 举例

  ```java
  class Person{
    //构造器 权限修饰符 类名(形参列表) { }
    public Person(){
  
    }
  }
  ```

- Java系统会自动定义构造器

  - 默认构造器的权限：取决于class的权限
  - 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
  - 一个类中可以有多个构造器，类似重载，参数内容不同
  - 一旦显式定义了类的构造器，系统就不再提供默认的空参构造器了

# this

## 为什么需要使用this

- 根据见名知意的要求，我们在写set方法的时候可能会想写成如下的样子

  ```java
  public void setAge(int age){
    age = age;
  }
  ```

  这种写法编译不会报错，但其实运行的时候这三个age全都被“就近原则”看成了同一个age

- 为了区分上述场景中的“属性”和“形参”，我们引入了this

  ```java
  public void setAge(int age){
    this.age = age;
  }
  ```

  this代表当前对象，所以前面的就是属性，后面的就是形参了

## this的使用

- this可以修饰 属性、方法、构造器【this(); this(age);】
- 规定：“this(形参列表)”必须声明在当前构造器的首行，且只能调用一次
- this 单独使用，表示当前对象 boy.marry(this)

# 匿名对象

- 匿名对象就是没有名字的对象
- new Phone().sendEmail();
- 这种情况下对象只能用一次，再使用匿名对象的时候其实对应的是一个新的对象。
- 开发中匿名对象常用的使用方法——常常作为参数传递下去使用，从而达到多次调用的目的。

```java
class PhoneMall{
  public void show(Phone phone){
    phone.sendemail();
    phone.playgame();
  }
}
//调用
PhoneMall mall = new PhoneMall();
mall.show(new Phone())

//类比理解一下匿名函数的这种用法
//小A写了一封信，没写名字，但是转送的时候小B帮小A写上了名字

```

# 重载

## 概念

- 重载overload
- 在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。
- 特点
  - 函数名相同
  - 返回值相同 / 不同
  - 参数列表必须不相同（个数或类型不同）
  - 参数类型相同，顺序不同 =>     也算作参数不同
  - 调用时，根据方法参数列表的不同来区别

## 重载进阶版—— 可变个数的形参

### 概念 —— Varargs机制

- JavaSE5.0开始，提供了Varargs(variable number of arguments)机制
- 允许直接定义能和多个实参相匹配的形参
- 目的：提供一种更简单的方式，来传递个数可变的实参

### 可变个数形参

- 格式

  - 数据类型 ... 变量名

- 举例

  ```java
  public void show(String ... strs){
  }
  //=> 这个方法可以识别匹配以下调用
  test.show("hello");
  test.show("hello","world");
  test.show("");
  //也就是说，传入多少个指定类型的参数都可以
  ```

- 注意点

  - 形参不同，可以和原方法重载。

    ==> show(String ... strs)可以和show(String str)同时存在。

  - 形参类型相同的数组，不可以构成重载。

    ==> 比如 show(String ... strs)可以和show(String[] str)不可以同时存在

  - 可变个数形参，必须放在参数表的末尾

    show(int i, String ... strs)可以

    shwo(String ... strs, int i)不可以

  - 同一个方法，最多只能声明一个可变个数形参

- 应用实例

  - 数据库中根据某些条件查找的时候，就常常会用到可变个数形参。

# 对象的内存解析

- 内存解析，是发生在“运行”阶段的。
- 编译完程序之后，生成一个或多个字节码文件。
- 我们使用JVM中的“类的加载器”和“解释器”对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。
- JVM的内存解析中，主要关心“运行时数据区”，关注heap，method area，VM stack
- 我们将局部变量存储在stack结构中
- 我们将局部变量存储在heap结构中
- 类的属性加载在heap空间中（非static，static在方法区）
